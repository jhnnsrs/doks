---
id: installation
title: Installation
sidebar_label: Installation
---

# Quickstart

The easiest way to install the library is to use poetry or pip:

```python
pip install arkitekt
```

As Arkitekt comes with a CLI, you can then use it to create a new project:

```python
arkitekt init
```

This will setup arkitekt in the local directory and guid you through connecting to your
local arkitekt instance for the first time. This will then generate a fakts.yaml file
that is used to configure the project.

# Usage

```python
from arkitekt import Arkitekt


app = Arkitekt()

with app:
    # do stuff with arkitekt


```

A few words about this setup:

1. Arkitekt relies on the concept of an application context. This is a context manager that
   is used to manage the lifecycle of the application (e.g setup connections to the backend
   and tear down these connections). This is used to ensure that the
   application is properly closed when it is no longer needed.

2. Within this context, you can use the `app` object to access the various services that
   Arkitekt provides. These services are available as attributes on the `app` object.
   For example, to access the `Fakts` service, you can use `app.fakts`.

3. The context manager also sets some context specific variables (contextvars).
   This means that some functionaly within this context will automatically use the governing
   app context. This allows for more functional code. For example, you can use simply call
   `from_xarray` to save an xarray on the mikro instance of the governing app context, without
   explicitly passing the app context to the function. You can always opt out of this behaviour
   by specifically passing the desired context to the function.

   ```python
    from arkitekt import Arkitekt
    from mikro import from_xarray
    import xarray as xr

    app = Arkitekt()

    with app:
        image = from_xarray(xr.DataArray((100,100,1), dims=["x", "y", "z"])) # stores the xarray on the mikro instance of the governing app context
   ```

   :::note
   This behaviour allows for more functional and concise code but can also lead to unexpected
   behaviour. For example, if you have multiple app contexts running in parallel, the
   `from_xarray` function will use the app context that is currently active. This can lead to
   unexpected behaviour if you are not aware of this.
   :::

4. By default the `app` object will use the `Fakts` service to connect to the backend and authenticate the app.
   This means that you can use the `app` object to access the backend without having to explicitly
   configure the application by pointing the service to an arkitekt. On the first call within
   the context, the `Fakts` service will try to connect to the backend using the `fakts.yaml`
   file in the current working directory. If this file does not exist, it will try to connect
   to the default arkitekt instance through an autodiscovering grant. You can change this behaviour
   by changing the fakts attributes before entering the context or by passing a different grant.

   ```python
    from arkitekt import Arkitekt
    from arkitekt.grants import ClientCredentialsGrant

    app = Arkitekt()

    app.fakts.grant = StaticDeviceGrant("my-device-id", "my-device-secret") # Set this grant to use a static device grant
    with app:
        # do stuff with arkitekt
   ```

5. Within the context you should avoid setting attributes on the `app`. Arkitekt was designed
   to be configured before entering the context.

6. Apps work both in async and synchronous contexts. This means that you can use the `app`
   object in both async and sync code. The `app` object will automatically detect the context
   and use the correct backend (check the documentation of koil for this). This means that you can use the same code in both async and
   sync code.

   ```python
    from arkitekt import Arkitekt
    import asyncio

    app = Arkitekt()

    async def main():
        async with app:
            # do stuff with arkitekt

    asyncio.run(main())
   ```

   :::note
   Arkitekt always uses an `asyncio` event loop internaly to manage the app context. In the non-async context, this event loop is
   run in a separate thread. Koil ensures that this threaded event loop is properly closed when the app context is closed, and bridges
   the calls between the threaded event loop and the main thread to ensure threadsafety. Btw: Threads started through rekuest are also
   able to call async / syncfuntions or the governing app context.
   :::
